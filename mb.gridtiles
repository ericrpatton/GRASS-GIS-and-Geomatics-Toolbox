#! /bin/bash
#
############################################################################
#
# MODULE:        mb.gridtiles 
# 
# AUTHOR(S):   	 Eric Patton, Geological Survey of Canada (Atlantic)
# 		         <epatton at nrcan dot gc dot ca>
#
# PURPOSE:       To (optionally) clean, process, grid and import an MB-System
# datalist. The module will split the gridding region into a number of smaller
# tiles ifthe entire size exceeds some threshold value.
#		 
# COPYRIGHT:     (C) 2009-2021 by Eric Patton
#
#                This program is free software under the GNU General Public
#                License (>=v3). Read the file COPYING that comes with
#                GRASS_out"
#                for details.
# 
# Last Modified: February 19, 2021
#
#############################################################################
#
#%Module
#% description: Processes, cleans, and segments an input datalist for import to GRASS.
#%END

#%flag
#% key: c 
#% description: Clean datalist.mb-1 using mbclean with default settings
#%END

#%flag
#% key: p 
#% description: Run mbprocess on datalist.mb-1 in parallel processing mode
#%END

#%option 
#% key: datalist
#% type: string
#% required: yes
#% answer: datalist.mb-1
#% description: Input MB-System datalist
#%END

#%option 
#% key: region
#% type: string
#% required: yes 
#% answer: INFO
#% description: Region to process (INFO|info or W/E/S/N)
#%END

#%option
#% key: resolution
#% type: integer
#% required : yes
#% answer: 100
#% description: Gridding resolution
#%END

#%option
#% key: datatype
#% type: integer
#% required : yes
#% answer: 2
#% description: mbgrid datatype (1=bathy; 2=topography; 3=amplitude; 4=sidescan)
#%END

if  [ -z "$GISBASE" ] ; then
    echo "You must be in GRASS GIS to run this program."
    exit 1
fi

if [ "$1" != "@ARGS_PARSED@" ] ; then
     exec g.parser "$0" "$@"
fi

DATALIST=${GIS_OPT_datalist}
REGION=${GIS_OPT_region}
RES=${GIS_OPT_resolution}
DATATYPE=${GIS_OPT_datatype}
OUTPUT_ROOT="$(basename $DATALIST .mb-1)_${RES}m"

SCRIPT=$(basename $0)
PAUSE=2

# The maximum number of raster rows and columns allowed before the input
# datalist region is split into equal-sized chunks. This is an arbitrary
# limit, but one based on experience using large rasters in GRASS.

MAXSIZE=400000000 # Discovered through trial and error on this machine

# Check if we have awk.
if [ ! -x "`which awk`" ] ; then
    echo "$SCRIPT: awk required, please install awk or gawk first" 2>&1
    exit 1
fi

# Check if we have bc.
if [ ! -x "`which bc`" ] ; then
    echo "$SCRIPT: bc required, please install bc first." 2>&1
    exit 1
fi

# Setting environment, so that awk works properly in all languages.
unset LC_ALL
export LC_NUMERIC=C

# Setup clean exit for Ctrl-C or similar breaks.
trap 'echo -e "\n\nUser break or similar caught! Exiting.\n" ; exit 1' 2 3 15

# Create the output filenames we'll need later in the script.
VECTOR_OUTPUT_ROOT=$(echo $OUTPUT_ROOT | sed 's/\./_/g')
VECT_BOUNDINGBOX="${VECTOR_OUTPUT_ROOT}_bounds"
RASTERBOUNDS="${VECT_BOUNDINGBOX}_rast"

if [ "$REGION" = "INFO" -o "$REGION" = "info" ] ; then 
	# v.in.boundingbox calls mb.getinforegion to capture maximum gridding region
	# of all files in the input datalist.  If there is a file in the current
	# directory named mbinfo.txt with the data extent already calculated, it is
	# used as the REGION. If not, mb.getinforegion is called to generate it. 
	
	echo -e "\nUsing mb.getinforegion to extract bounds of the datalist extent. Please standby...\n"

	# The -i flag will use an mbinfo 'info.txt' file to extract the bounds, or,
	# if one is not available, it will call mb.getinforegion to create one from
	# the datalist. The -r flag generates a raster of the incoming vector
	# boundingbox. The raster boundingbox is split by r.fragment into strips if
	# the full region extent is bigger than $MAXSIZE.
	v.in.boundingbox -ir boundingbox=${VECT_BOUNDINGBOX} datalist=${DATALIST} --o 
	echo -e "\nFound the following region through mb.getinforegion:\n"
	g.region rast=${RASTERBOUNDS} res=${RES} -ap
	echo ""

else
	# Use the region provided by the user.

	echo -e "\nUsing user-provided region. Please standby...\n"
	MAX_WEST=$(echo $REGION | cut -d'/' -f1)
	MAX_EAST=$(echo $REGION | cut -d'/' -f2)
	MAX_SOUTH=$(echo $REGION | cut -d'/' -f3)
	MAX_NORTH=$(echo $REGION | cut -d'/' -f4)

	echo "$MAX_WEST $MAX_SOUTH" | proj $(g.proj -jf) | awk '{print $1, $2}' > coords.txt
	echo "$MAX_WEST $MAX_NORTH" | proj $(g.proj -jf) | awk '{print $1, $2}' >> coords.txt
	echo "$MAX_EAST $MAX_NORTH" | proj $(g.proj -jf) | awk '{print $1, $2}' >> coords.txt
	echo "$MAX_EAST $MAX_SOUTH" | proj $(g.proj -jf) | awk '{print $1, $2}' >> coords.txt    
                                                                             
	# In most projections, the westing value is lower than the easting.  The -r
	# flag in the sort command reverses the sorting, placing the max value in
	# the first row.
#	WESTING=$(sort -n -k1 coords.txt | awk 'NR == 1 {print $1}')
#	EASTING=$(sort -n -r -k1 coords.txt | awk 'NR == 1 {print $1}')
#	SOUTHING=$(sort -n -k2 coords.txt | awk 'NR == 1 {print $2}')
#	NORTHING=$(sort -n -r -k2 coords.txt | awk 'NR == 1 {print $2}')
	
	WESTING=$(awk 'NR == 1 {print $1}' coords.txt)
	EASTING=$(awk 'NR == 3 {print $1}' coords.txt)
	SOUTHING=$(awk 'NR == 4 {print $2}' coords.txt)
	NORTHING=$(awk 'NR == 2 {print $2}' coords.txt)

	g.region w=${WESTING} e=${EASTING} s=${SOUTHING} n=${NORTHING} res=${RES} -ap
	echo "" ; sleep $PAUSE
	
	# The -g flag below will use the current region set by g.region, and the -r
	# flag will create a raster from the vector bounding box. v.in.boundingbox
	# will create a raster with the default name of $RASTERBOUNDS, that is,
	# $VECT_BOUNDINGBOX_rast.
	v.in.boundingbox -gr boundingbox=${VECT_BOUNDINGBOX} datalist=${DATALIST} --o 
fi

# If the -c flag is passed, run mbclean on the datalist using default settings.
# Since it only makes sense to use the -c flag on a raw datalist, we have to
# make sure to set mbgridtiles to use a processed version of the datalist
# afterwards.

# -C is the slope filter (degrees)
# -D is the minimum and maximum allowed distances on which the flagging 
#    algorithms will operate, as a percentage of local median depth.
# -G is the acceptable depth percentage filter
# -P is the acceptable speed range filter (km/hr)
# -W is the geographic region filter
# -Z is the 0 lat/long filter; probably redundant with -G
if  [ ${GIS_FLAG_c} -eq 1 ] ; then
	echo -e "\nThe -c flag has been passed; running mbclean..."
	sleep ${PAUSE}
	mbclean -F-1 -I ${DATALIST} -M1 -C75/2 -D0.01/0.2 -G0.98/1.02 -W-141/30/30/85 -P0.1/35 -Z
fi

if  [ ${GIS_FLAG_p} -eq 1 ] ; then
	echo -e "\nThe -p flag has been passed; running mbprocess..."
	sleep ${PAUSE}
	mbprocess -F-1 -I ${DATALIST} -C8
fi

echo ""
mbdatalist -F-1 -I ${DATALIST} -Z
DATALIST="$(basename $DATALIST .mb-1)p.mb-1"
OUTPUT_ROOT="$(basename $DATALIST .mb-1)_${RES}m"
echo -e "\nThe datalist is now $DATALIST."
echo "The output filename root has been updated to $OUTPUT_ROOT."
sleep ${PAUSE}

ROWS=$(g.region -pg | grep rows | cut -d'=' -f2)
COLS=$(g.region -pg | grep cols | cut -d'=' -f2)
CELLS=$(g.region -pg | grep cells | cut -d'=' -f2)
CELLS_INT=`echo "$CELLS" | awk '{printf "%.0f", $1}'`
ROWS_INT=`echo "$ROWS" | awk '{printf "%.0f", $1}'`
COLS_INT=`echo "$COLS" | awk '{printf "%.0f", $1}'`

# Check to see if the number of cells in the region is greater than our threshold
# value. If so, we need to partition the region into sections so that mbgrid
# doesn't crash from a malloc error. (MB-System leaves the memory management to
# you). If we need to segment the region, calculate how many strips needed.  We
# will halve the width of the datalist region, then recheck whether the rows *
# cols of that region still exceeds the MAXSIZE; this process is repeated until
# the product of the rows and columns is below the MAXSIZE threshold; this will
# be the value of our STRIP_WIDTH_CELLS.

# Initialize a couple variables prior to beginning the WHILE loop..."

if [ "$CELLS_INT" -gt "$MAXSIZE" ] ; then
	COLS_WIDTH_CHECK=$COLS
	NUMBER_OF_HALVINGS=0
	NUMBER_OF_FRAGMENT_COLS=1
	SIZE_CHECK=$CELLS_INT

	while [ $SIZE_CHECK -gt $MAXSIZE ] ; do

		echo -e "\nThe processing region is $SIZE_CHECK cells, which exceeds limit of $MAXSIZE cells."
		sleep $PAUSE

		# We halve the region, splitting it in two
		COLS_WIDTH_CHECK=$(echo "scale=2 ; $COLS_WIDTH_CHECK / 2" | bc -l)
		NUMBER_OF_HALVINGS=$(( $NUMBER_OF_HALVINGS + 1 ))
		NUMBER_OF_FRAGMENT_COLS=$(echo "$NUMBER_OF_HALVINGS * 2" | bc -l)
		SIZE_CHECK=$(echo "$COLS_WIDTH_CHECK * $ROWS" | bc -l | awk '{printf "%.0f", $1}')
		
		echo "The COLS_WIDTH_CHECK has been halved to $COLS_WIDTH_CHECK."
		echo "NUMBER_OF_HALVINGS is now $NUMBER_OF_HALVINGS."
		echo "NUMBER_OF_FRAGMENT_COLS is now $NUMBER_OF_FRAGMENT_COLS."
		echo "The SIZE_CHECK is now $SIZE_CHECK."
		sleep 10

	done
	
	echo "We will need to split the region of $DATALIST into $NUMBER_OF_FRAGMENT_COLS strips of size $SIZE_CHECK."
	sleep $PAUSE

	r.fragment input=${RASTERBOUNDS} rows=1 cols=${NUMBER_OF_FRAGMENT_COLS} -v 
	
	COUNTER=0 

	for STRIP in $(g.list type=rast pat="${RASTERBOUNDS}_?_?") ; do
		g.region rast=${STRIP} res=${RES} -a

		CURRENT_WEST_LL=$(g.region -bg rast=${STRIP} --q | grep ll_w | cut -d'=' -f2)
		CURRENT_EAST_LL=$(g.region -bg rast=${STRIP} --q | grep ll_e | cut -d'=' -f2)
		CURRENT_SOUTH_LL=$(g.region -bg rast=${STRIP} --q | grep ll_s | cut -d'=' -f2)
		CURRENT_NORTH_LL=$(g.region -bg rast=${STRIP} --q | grep ll_n | cut -d'=' -f2)

		COUNTER=$(($COUNTER + 1))

		echo -e "\n======= GRIDDING BATHYMETRY WITH MB-GRID ========="
		sleep $PAUSE
		echo -e "\nGridding section $COUNTER of $NUMBER_OF_FRAGMENT_COLS...please standby."

		# We are creating a lat-long grid here; The script can be more useful if
		# it is projection-agnostic. We can always project the grid afterwards.
		# (I used to hard-code a UTM projecton, which wasn't useful in LCC Grass
		# projects). The mbgrid default output is a netCDF grid (.grd).

		mbgrid -A${DATATYPE} -C2/1 -E${RES}/${RES}/meters! -F1 -I ${DATALIST} -R${CURRENT_WEST_LL}/${CURRENT_EAST_LL}/${CURRENT_SOUTH_LL}/${CURRENT_NORTH_LL} -O ${OUTPUT_ROOT}_${COUNTER} -V
				
		echo -e "\nReprojecting with gdalwarp...\n"
		gdalwarp -s_srs "EPSG:4326" -t_srs "$(g.proj -jf)" -tr ${RES} ${RES} -wm 30000000000 -r bilinear -multi -wo NUM_THREADS=ALL_CPUS -of "GTiff" ${OUTPUT_ROOT}_${COUNTER}.grd ${OUTPUT_ROOT}_${COUNTER}.tif
		echo "Importing section $COUNTER into Grass..."		
		r.in.gdal input="${OUTPUT_ROOT}_${COUNTER}.tif" mem=30000 output="${OUTPUT_ROOT}_${COUNTER}_out" -o --o --v
		sleep $PAUSE
	
	done
		
	echo -e "\nPatching sections together...\n"	
	g.region rast=$(g.list type=rast pattern="${OUTPUT_ROOT}_*_out" sep=,) res=${RES} -a
	r.patch input=$(g.list type=rast pattern="${OUTPUT_ROOT}_*_out" sep=,) output=${OUTPUT_ROOT} --o --v
	
	[[ $? -eq 0 ]] && g.remove type=rast pat="${OUTPUT_ROOT}_*_out" -f --q

else
	echo -e "\n======= GRIDDING BATHYMETRY WITH MB-GRID ========="
	echo -e "\nThe processing region is $CELLS_INT out of an allowable $MAXSIZE."
	echo -e "Gridding the bathymetry as one chunk...please standby.\n"
	sleep $PAUSE
	
	MAX_WEST_LL=$(g.region -bg rast=${RASTERBOUNDS} --q | grep ll_w | cut -d'=' -f2)
	MAX_EAST_LL=$(g.region -bg rast=${RASTERBOUNDS} --q | grep ll_e | cut -d'=' -f2)
	MAX_SOUTH_LL=$(g.region -bg rast=${RASTERBOUNDS} --q | grep ll_s | cut -d'=' -f2)
	MAX_NORTH_LL=$(g.region -bg rast=${RASTERBOUNDS} --q | grep ll_n | cut -d'=' -f2)
	
	#mbgrid -A${DATATYPE} -C2/1 -E${RES}/${RES}/meters! -F1 -I ${DATALIST} -R${MAX_WEST_LL}/${MAX_EAST_LL}/${MAX_SOUTH_LL}/${MAX_NORTH_LL} -O ${OUTPUT_ROOT} -V
	mbgrid -A${DATATYPE} -C2/1 -E${RES}/${RES}/meters! -F1 -I ${DATALIST} -R${MAX_WEST_LL}/${MAX_EAST_LL}/${MAX_SOUTH_LL}/${MAX_NORTH_LL} -O ${OUTPUT_ROOT} -V
	
	echo -e "Reprojecting with gdalwarp...\n"
	gdalwarp -s_srs "EPSG:4326" -t_srs "$(g.proj -jf)" -of "GTiff" -tr ${RES} ${RES} -wm 30000000000 -r bilinear -multi -wo NUM_THREADS=ALL_CPUS ${OUTPUT_ROOT}.grd ${OUTPUT_ROOT}.tif
	echo -e "\nImporting grid into Grass...\n"		
	r.in.gdal input=${OUTPUT_ROOT}.tif mem=28000 output=${OUTPUT_ROOT} -o --o --v
	
fi

r.colors -e map=${OUTPUT_ROOT} color=bof_unb --q
r.csr input=${OUTPUT_ROOT}

# Cleanup
rm ${OUTPUT_ROOT}*.grd
[[ -f "coords.txt" ]] && rm coords.txt

echo -e "\n$SCRIPT: Done."

exit 0
